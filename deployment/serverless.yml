org: clash
app: clash

service: clash-api4

custom:
  # Our stage is based on what is passed in when running serverless
  # commands. Or fallsback to what we have set in the provider section.
  stage: ${opt:stage, self:provider.stage}
  region:
    dev: us-east-2
    qa: us-east-1
    prod: us-west-1
  # TODO : these should be imported from VPC stack export
  PublicSubnet2Id:
    dev: subnet-0aca1eeeb46c94608
    qa: subnet-08912742fc69e6806
    prod: subnet-05913a06f8faba7f6
  ServiceName: clash-api4
  # see for availiable values https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-cpu
  ContainerCpu: 1024 # 1024 is 1 CPU
  ContainerMemory: 2048 #in MB
  Image: # The docker image
    dev: fbielejec/grpc-chat #fbielejec/route-guide
    qa: TODO
    prod: TODO #854738110479.dkr.ecr.us-west-1.amazonaws.com/api2-service:latest
  ContainerPort: 50051 # What port number the application inside the docker container is binding to
  DesiredCount: # How many copies of the service task to run
    dev: 2
    qa: 2
    prod: 2
  Path: '*'
  Priority: 1
  CertificateArn:
    dev: arn:aws:acm:us-east-2:854738110479:certificate/8ceee094-678e-4484-bcd8-28f9f683eeda
    qa: arn:aws:acm:us-east-1:854738110479:certificate/98661eb6-86c2-4e8b-ae8d-1182d9e9e146
    prod: arn:aws:acm:us-west-1:854738110479:certificate/1231d89a-bafe-4db0-8d51-f1dc0fe098e2

provider:
  name: aws
  profile: clash
  region: ${self:custom.region.${self:custom.stage}, self.region.dev}
  stage: dev
  deploymentBucket: clash-${self:custom.stage}-serverlessdeploymentbucket

resources:
  Resources:
    LogGroup:
      Type: AWS::Logs::LogGroup
      Properties:
        LogGroupName: '/ecs/clash-api4-${self:custom.stage}'
        RetentionInDays: 7

    # The task definition. This is a simple metadata description of what
    # container to run, and what resource requirements it has.
    TaskDefinition:
      Type: AWS::ECS::TaskDefinition
      Properties:
        Family: ${self:custom.ServiceName}
        Cpu: ${self:custom.ContainerCpu}
        Memory: ${self:custom.ContainerMemory}
        NetworkMode: awsvpc
        RequiresCompatibilities:
          - FARGATE
        ExecutionRoleArn: {'Fn::ImportValue': '${self:custom.stage}-ecs-task-role-id'}
      # TaskRoleArn: !Ref 'Role' # IAM role to give the service containers if the code within needs access to other AWS resources
        ContainerDefinitions:
          - Name: ${self:custom.ServiceName}
            Cpu: ${self:custom.ContainerCpu}
            Memory: ${self:custom.ContainerMemory}
            Image: ${self:custom.Image.${self:custom.stage}, self.Image.dev}
            PortMappings:
              - ContainerPort: ${self:custom.ContainerPort}
            LogConfiguration:
              LogDriver: awslogs
              options:
                awslogs-group: '/ecs/clash-api4-${self:custom.stage}'
                awslogs-region: ${self:custom.region.${self:custom.stage}, self.region.dev}
                awslogs-stream-prefix: 'ecs'
            # ENV vars for container
            # Environment:
            #   - Name: 'API_LOGGING_LEVEL'
            #     Value: ${env:API_LOGGING_LEVEL}
            #   - Name: 'API_REDIS_HOST'
            #     Value: ${env:API_REDIS_HOST}

    # The service. The service is a resource which allows you to run multiple
    # copies of a type of task, and gather up their logs and metrics, as well
    # as monitor the number of running tasks and replace any that have crashed
    Service:
      Type: AWS::ECS::Service
      DependsOn:
        - LoadBalancerRule
      Properties:
        ServiceName: ${self:custom.ServiceName}
        Cluster: {'Fn::ImportValue': '${self:custom.stage}-clash-ecs-id'}
        LaunchType: FARGATE
        DeploymentConfiguration:
          MaximumPercent: 200
          MinimumHealthyPercent: 75
        DesiredCount: ${self:custom.DesiredCount.${self:custom.stage}, self.DesiredCount.dev}
        NetworkConfiguration:
          AwsvpcConfiguration:
            AssignPublicIp: DISABLED
            SecurityGroups:
              - {'Fn::ImportValue': '${self:custom.stage}-ecs-container-security-group2-id'}
            Subnets:
              - {'Fn::ImportValue': '${self:custom.stage}-private-subnet1-id'}
              - {'Fn::ImportValue': '${self:custom.stage}-private-subnet2-id'}
        TaskDefinition: !Ref 'TaskDefinition'
        LoadBalancers:
          - ContainerName: ${self:custom.ServiceName}
            ContainerPort: ${self:custom.ContainerPort}
            TargetGroupArn: !Ref 'TargetGroup'

    # Public facing ALB
    LoadBalancer:
      Type: AWS::ElasticLoadBalancingV2::LoadBalancer
      Properties:
        Name: ${self:custom.stage}-api4-balancer
        Scheme: internet-facing
        LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
        Subnets:
          # The load balancer is placed into the public subnets, so that traffic
          # from the internet can reach the load balancer directly via the internet gateway
          - {'Fn::ImportValue': '${self:custom.stage}-public-subnet1-id'}
          - ${self:custom.PublicSubnet2Id.${self:custom.stage}, self.PublicSubnet2Id.dev}
        SecurityGroups:
          - {'Fn::ImportValue': '${self:custom.stage}-public-load-balancer-security-group-id'}

    # A target group. This is used for keeping track of all the tasks, and
    # what IP addresses / port numbers they have. You can query it yourself,
    # to use the addresses yourself, but most often this target group is just
    # connected to an application load balancer, or network load balancer, so
    # it can automatically distribute traffic across all the targets.
    TargetGroup:
      Type: AWS::ElasticLoadBalancingV2::TargetGroup
      Properties:
        HealthCheckIntervalSeconds: 6
        HealthCheckPath: / #/pingpong.PingPong/SendPing
        # Matcher:
        #   HttpCode: 12 # gRPC for not implemented
        HealthCheckProtocol: HTTP
        HealthCheckTimeoutSeconds: 5
        HealthyThresholdCount: 2
        TargetType: ip
        Name: ${self:custom.ServiceName}
        Port: ${self:custom.ContainerPort}
        Protocol: HTTP
        ProtocolVersion: GRPC
        UnhealthyThresholdCount: 2
        VpcId: {'Fn::ImportValue': '${self:custom.stage}-vpc-id'}

    LoadBalancerListener:
      Type: AWS::ElasticLoadBalancingV2::Listener
      DependsOn:
        - LoadBalancer
      Properties:
        DefaultActions:
          - TargetGroupArn: !Ref 'TargetGroup'
            Type: 'forward'
        LoadBalancerArn: !Ref 'LoadBalancer'
        Port: 443
        Protocol: HTTPS
        Certificates:
          - CertificateArn: ${self:custom.CertificateArn.${self:custom.stage}}

    # Create a rule on the load balancer for routing traffic to the target group
    LoadBalancerRule:
      Type: AWS::ElasticLoadBalancingV2::ListenerRule
      Properties:
        Actions:
          - TargetGroupArn: !Ref 'TargetGroup'
            Type: 'forward'
        Conditions:
          - Field: path-pattern
            Values:
              - ${self:custom.Path}
        ListenerArn: !Ref 'LoadBalancerListener'
        Priority: ${self:custom.Priority}
